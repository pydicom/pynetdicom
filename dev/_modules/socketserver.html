

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>socketserver &mdash; pynetdicom 1.4.0.dev0 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/pynetdicom.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/pynetdicom.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> pynetdicom
          

          
            
            <img src="../_static/pydicom_flat_black.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                1.4.0.dev0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../verification_service_class.html">Verification Service Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../storage_service_class.html">Storage Service Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../query_retrieve_service_class.html">Query/Retrieve Service Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basic_worklist_service_class.html">Basic Worklist Management Service Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../relevant_patient_service_class.html">Relevant Patient Information Query Service Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../substance_admin_service_class.html">Substance Administration Query Service Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../non_patient_service_class.html">Non-Patient Object Storage Service Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../color_palette_service_class.html">Color Palette Query/Retrieve Service Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../defined_procedure_service_class.html">Defined Procedure Protocol Query/Retrieve Service Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../hanging_protocol_service_class.html">Hanging Protocol Query/Retrieve Service Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../implant_template_service_class.html">Implant Template Query/Retrieve Service Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../display_system_service_class.html">Display System Management Service Class</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modality_performed_procedure_step.html">Modality Performed Procedure Step Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../protocol_approval_service_class.html">Protocol Approval Query/Retrieve Service Class</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">User Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html">1.4.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html#v1-3-0">1.3.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html#v1-2-0">1.2.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html#v1-1-0">1.1.0</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes.html#v1-0-0">1.0.0</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pynetdicom</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>socketserver</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for socketserver</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Generic socket server classes.</span>

<span class="sd">This module tries to capture the various aspects of defining a server:</span>

<span class="sd">For socket-based servers:</span>

<span class="sd">- address family:</span>
<span class="sd">        - AF_INET{,6}: IP (Internet Protocol) sockets (default)</span>
<span class="sd">        - AF_UNIX: Unix domain sockets</span>
<span class="sd">        - others, e.g. AF_DECNET are conceivable (see &lt;socket.h&gt;</span>
<span class="sd">- socket type:</span>
<span class="sd">        - SOCK_STREAM (reliable stream, e.g. TCP)</span>
<span class="sd">        - SOCK_DGRAM (datagrams, e.g. UDP)</span>

<span class="sd">For request-based servers (including socket-based):</span>

<span class="sd">- client address verification before further looking at the request</span>
<span class="sd">        (This is actually a hook for any processing that needs to look</span>
<span class="sd">         at the request before anything else, e.g. logging)</span>
<span class="sd">- how to handle multiple requests:</span>
<span class="sd">        - synchronous (one request is handled at a time)</span>
<span class="sd">        - forking (each request is handled by a new process)</span>
<span class="sd">        - threading (each request is handled by a new thread)</span>

<span class="sd">The classes in this module favor the server type that is simplest to</span>
<span class="sd">write: a synchronous TCP/IP server.  This is bad class design, but</span>
<span class="sd">save some typing.  (There&#39;s also the issue that a deep class hierarchy</span>
<span class="sd">slows down method lookups.)</span>

<span class="sd">There are five classes in an inheritance diagram, four of which represent</span>
<span class="sd">synchronous servers of four types:</span>

<span class="sd">        +------------+</span>
<span class="sd">        | BaseServer |</span>
<span class="sd">        +------------+</span>
<span class="sd">              |</span>
<span class="sd">              v</span>
<span class="sd">        +-----------+        +------------------+</span>
<span class="sd">        | TCPServer |-------&gt;| UnixStreamServer |</span>
<span class="sd">        +-----------+        +------------------+</span>
<span class="sd">              |</span>
<span class="sd">              v</span>
<span class="sd">        +-----------+        +--------------------+</span>
<span class="sd">        | UDPServer |-------&gt;| UnixDatagramServer |</span>
<span class="sd">        +-----------+        +--------------------+</span>

<span class="sd">Note that UnixDatagramServer derives from UDPServer, not from</span>
<span class="sd">UnixStreamServer -- the only difference between an IP and a Unix</span>
<span class="sd">stream server is the address family, which is simply repeated in both</span>
<span class="sd">unix server classes.</span>

<span class="sd">Forking and threading versions of each type of server can be created</span>
<span class="sd">using the ForkingMixIn and ThreadingMixIn mix-in classes.  For</span>
<span class="sd">instance, a threading UDP server class is created as follows:</span>

<span class="sd">        class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass</span>

<span class="sd">The Mix-in class must come first, since it overrides a method defined</span>
<span class="sd">in UDPServer! Setting the various member variables also changes</span>
<span class="sd">the behavior of the underlying server mechanism.</span>

<span class="sd">To implement a service, you must derive a class from</span>
<span class="sd">BaseRequestHandler and redefine its handle() method.  You can then run</span>
<span class="sd">various versions of the service by combining one of the server classes</span>
<span class="sd">with your request handler class.</span>

<span class="sd">The request handler class must be different for datagram or stream</span>
<span class="sd">services.  This can be hidden by using the request handler</span>
<span class="sd">subclasses StreamRequestHandler or DatagramRequestHandler.</span>

<span class="sd">Of course, you still have to use your head!</span>

<span class="sd">For instance, it makes no sense to use a forking server if the service</span>
<span class="sd">contains state in memory that can be modified by requests (since the</span>
<span class="sd">modifications in the child process would never reach the initial state</span>
<span class="sd">kept in the parent process and passed to each child).  In this case,</span>
<span class="sd">you can use a threading server, but you will probably have to use</span>
<span class="sd">locks to avoid two requests that come in nearly simultaneous to apply</span>
<span class="sd">conflicting changes to the server state.</span>

<span class="sd">On the other hand, if you are building e.g. an HTTP server, where all</span>
<span class="sd">data is stored externally (e.g. in the file system), a synchronous</span>
<span class="sd">class will essentially render the service &quot;deaf&quot; while one request is</span>
<span class="sd">being handled -- which may be for a very long time if a client is slow</span>
<span class="sd">to read all the data it has requested.  Here a threading or forking</span>
<span class="sd">server is appropriate.</span>

<span class="sd">In some cases, it may be appropriate to process part of a request</span>
<span class="sd">synchronously, but to finish processing in a forked child depending on</span>
<span class="sd">the request data.  This can be implemented by using a synchronous</span>
<span class="sd">server and doing an explicit fork in the request handler class</span>
<span class="sd">handle() method.</span>

<span class="sd">Another approach to handling multiple simultaneous requests in an</span>
<span class="sd">environment that supports neither threads nor fork (or where these are</span>
<span class="sd">too expensive or inappropriate for the service) is to maintain an</span>
<span class="sd">explicit table of partially finished requests and to use a selector to</span>
<span class="sd">decide which request to work on next (or whether to handle a new</span>
<span class="sd">incoming request).  This is particularly important for stream services</span>
<span class="sd">where each client can potentially be connected for a long time (if</span>
<span class="sd">threads or subprocesses cannot be used).</span>

<span class="sd">Future work:</span>
<span class="sd">- Standard classes for Sun RPC (which uses either UDP or TCP)</span>
<span class="sd">- Standard mix-in classes to implement various authentication</span>
<span class="sd">  and encryption schemes</span>

<span class="sd">XXX Open problems:</span>
<span class="sd">- What to do with out-of-band data?</span>

<span class="sd">BaseServer:</span>
<span class="sd">- split generic &quot;request&quot; functionality out into BaseServer class.</span>
<span class="sd">  Copyright (C) 2000  Luke Kenneth Casson Leighton &lt;lkcl@samba.org&gt;</span>

<span class="sd">  example: read entries from a SQL database (requires overriding</span>
<span class="sd">  get_request() to return a table entry from the database).</span>
<span class="sd">  entry is processed by a RequestHandlerClass.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Author of the BaseServer patch: Luke Kenneth Casson Leighton</span>

<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.4&quot;</span>


<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">selectors</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">errno</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">threading</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">dummy_threading</span> <span class="k">as</span> <span class="nn">threading</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">BufferedIOBase</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="k">import</span> <span class="n">monotonic</span> <span class="k">as</span> <span class="n">time</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;BaseServer&quot;</span><span class="p">,</span> <span class="s2">&quot;TCPServer&quot;</span><span class="p">,</span> <span class="s2">&quot;UDPServer&quot;</span><span class="p">,</span>
           <span class="s2">&quot;ThreadingUDPServer&quot;</span><span class="p">,</span> <span class="s2">&quot;ThreadingTCPServer&quot;</span><span class="p">,</span>
           <span class="s2">&quot;BaseRequestHandler&quot;</span><span class="p">,</span> <span class="s2">&quot;StreamRequestHandler&quot;</span><span class="p">,</span>
           <span class="s2">&quot;DatagramRequestHandler&quot;</span><span class="p">,</span> <span class="s2">&quot;ThreadingMixIn&quot;</span><span class="p">]</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s2">&quot;fork&quot;</span><span class="p">):</span>
    <span class="n">__all__</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;ForkingUDPServer&quot;</span><span class="p">,</span><span class="s2">&quot;ForkingTCPServer&quot;</span><span class="p">,</span> <span class="s2">&quot;ForkingMixIn&quot;</span><span class="p">])</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="s2">&quot;AF_UNIX&quot;</span><span class="p">):</span>
    <span class="n">__all__</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;UnixStreamServer&quot;</span><span class="p">,</span><span class="s2">&quot;UnixDatagramServer&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;ThreadingUnixStreamServer&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;ThreadingUnixDatagramServer&quot;</span><span class="p">])</span>

<span class="c1"># poll/select have the advantage of not requiring any extra file descriptor,</span>
<span class="c1"># contrarily to epoll/kqueue (also, they require a single syscall).</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">selectors</span><span class="p">,</span> <span class="s1">&#39;PollSelector&#39;</span><span class="p">):</span>
    <span class="n">_ServerSelector</span> <span class="o">=</span> <span class="n">selectors</span><span class="o">.</span><span class="n">PollSelector</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">_ServerSelector</span> <span class="o">=</span> <span class="n">selectors</span><span class="o">.</span><span class="n">SelectSelector</span>


<span class="k">class</span> <span class="nc">BaseServer</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;Base class for server classes.</span>

<span class="sd">    Methods for the caller:</span>

<span class="sd">    - __init__(server_address, RequestHandlerClass)</span>
<span class="sd">    - serve_forever(poll_interval=0.5)</span>
<span class="sd">    - shutdown()</span>
<span class="sd">    - handle_request()  # if you do not use serve_forever()</span>
<span class="sd">    - fileno() -&gt; int   # for selector</span>

<span class="sd">    Methods that may be overridden:</span>

<span class="sd">    - server_bind()</span>
<span class="sd">    - server_activate()</span>
<span class="sd">    - get_request() -&gt; request, client_address</span>
<span class="sd">    - handle_timeout()</span>
<span class="sd">    - verify_request(request, client_address)</span>
<span class="sd">    - server_close()</span>
<span class="sd">    - process_request(request, client_address)</span>
<span class="sd">    - shutdown_request(request)</span>
<span class="sd">    - close_request(request)</span>
<span class="sd">    - service_actions()</span>
<span class="sd">    - handle_error()</span>

<span class="sd">    Methods for derived classes:</span>

<span class="sd">    - finish_request(request, client_address)</span>

<span class="sd">    Class variables that may be overridden by derived classes or</span>
<span class="sd">    instances:</span>

<span class="sd">    - timeout</span>
<span class="sd">    - address_family</span>
<span class="sd">    - socket_type</span>
<span class="sd">    - allow_reuse_address</span>

<span class="sd">    Instance variables:</span>

<span class="sd">    - RequestHandlerClass</span>
<span class="sd">    - socket</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">timeout</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">server_address</span><span class="p">,</span> <span class="n">RequestHandlerClass</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server_address</span> <span class="o">=</span> <span class="n">server_address</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RequestHandlerClass</span> <span class="o">=</span> <span class="n">RequestHandlerClass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__is_shut_down</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__shutdown_request</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">server_activate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called by constructor to activate the server.</span>

<span class="sd">        May be overridden.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">serve_forever</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">poll_interval</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handle one request at a time until shutdown.</span>

<span class="sd">        Polls for shutdown every poll_interval seconds. Ignores</span>
<span class="sd">        self.timeout. If you need to do periodic tasks, do them in</span>
<span class="sd">        another thread.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__is_shut_down</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># XXX: Consider using another file descriptor or connecting to the</span>
            <span class="c1"># socket to wake this up instead of polling. Polling reduces our</span>
            <span class="c1"># responsiveness to a shutdown request and wastes cpu at all other</span>
            <span class="c1"># times.</span>
            <span class="k">with</span> <span class="n">_ServerSelector</span><span class="p">()</span> <span class="k">as</span> <span class="n">selector</span><span class="p">:</span>
                <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selectors</span><span class="o">.</span><span class="n">EVENT_READ</span><span class="p">)</span>

                <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__shutdown_request</span><span class="p">:</span>
                    <span class="n">ready</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">poll_interval</span><span class="p">)</span>
                    <span class="c1"># bpo-35017: shutdown() called during select(), exit immediately.</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__shutdown_request</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="n">ready</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_handle_request_noblock</span><span class="p">()</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">service_actions</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__shutdown_request</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__is_shut_down</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">shutdown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stops the serve_forever loop.</span>

<span class="sd">        Blocks until the loop has finished. This must be called while</span>
<span class="sd">        serve_forever() is running in another thread, or it will</span>
<span class="sd">        deadlock.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__shutdown_request</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__is_shut_down</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">service_actions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called by the serve_forever() loop.</span>

<span class="sd">        May be overridden by a subclass / Mixin to implement any code that</span>
<span class="sd">        needs to be run during the loop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="c1"># The distinction between handling, getting, processing and finishing a</span>
    <span class="c1"># request is fairly arbitrary.  Remember:</span>
    <span class="c1">#</span>
    <span class="c1"># - handle_request() is the top-level call.  It calls selector.select(),</span>
    <span class="c1">#   get_request(), verify_request() and process_request()</span>
    <span class="c1"># - get_request() is different for stream or datagram sockets</span>
    <span class="c1"># - process_request() is the place that may fork a new process or create a</span>
    <span class="c1">#   new thread to finish the request</span>
    <span class="c1"># - finish_request() instantiates the request handler class; this</span>
    <span class="c1">#   constructor will handle the request all by itself</span>

    <span class="k">def</span> <span class="nf">handle_request</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handle one request, possibly blocking.</span>

<span class="sd">        Respects self.timeout.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Support people who used socket.settimeout() to escape</span>
        <span class="c1"># handle_request before self.timeout was available.</span>
        <span class="n">timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">gettimeout</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">deadline</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span>

        <span class="c1"># Wait until a request arrives or the timeout expires - the loop is</span>
        <span class="c1"># necessary to accommodate early wakeups due to EINTR.</span>
        <span class="k">with</span> <span class="n">_ServerSelector</span><span class="p">()</span> <span class="k">as</span> <span class="n">selector</span><span class="p">:</span>
            <span class="n">selector</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selectors</span><span class="o">.</span><span class="n">EVENT_READ</span><span class="p">)</span>

            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">ready</span> <span class="o">=</span> <span class="n">selector</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ready</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle_request_noblock</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">timeout</span> <span class="o">=</span> <span class="n">deadline</span> <span class="o">-</span> <span class="n">time</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_timeout</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_handle_request_noblock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handle one request, without blocking.</span>

<span class="sd">        I assume that selector.select() has returned that the socket is</span>
<span class="sd">        readable before this function was called, so there should be no risk of</span>
<span class="sd">        blocking in get_request().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_request</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verify_request</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">process_request</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">handle_error</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shutdown_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shutdown_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
                <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shutdown_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">handle_timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called if no new request arrives within self.timeout.</span>

<span class="sd">        Overridden by ForkingMixIn.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">verify_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verify the request.  May be overridden.</span>

<span class="sd">        Return True if we should proceed with this request.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">process_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call finish_request.</span>

<span class="sd">        Overridden by ForkingMixIn and ThreadingMixIn.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finish_request</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shutdown_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">server_close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called to clean-up the server.</span>

<span class="sd">        May be overridden.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">finish_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Finish one request by instantiating RequestHandlerClass.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">RequestHandlerClass</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">shutdown_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called to shutdown and close an individual request.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">close_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called to clean up an individual request.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">handle_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Handle an error gracefully.  May be overridden.</span>

<span class="sd">        The default is to print a traceback and continue.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">40</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Exception happened during processing of request from&#39;</span><span class="p">,</span>
            <span class="n">client_address</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">traceback</span>
        <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">40</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server_close</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">TCPServer</span><span class="p">(</span><span class="n">BaseServer</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Base class for various socket-based server classes.</span>

<span class="sd">    Defaults to synchronous IP stream (i.e., TCP).</span>

<span class="sd">    Methods for the caller:</span>

<span class="sd">    - __init__(server_address, RequestHandlerClass, bind_and_activate=True)</span>
<span class="sd">    - serve_forever(poll_interval=0.5)</span>
<span class="sd">    - shutdown()</span>
<span class="sd">    - handle_request()  # if you don&#39;t use serve_forever()</span>
<span class="sd">    - fileno() -&gt; int   # for selector</span>

<span class="sd">    Methods that may be overridden:</span>

<span class="sd">    - server_bind()</span>
<span class="sd">    - server_activate()</span>
<span class="sd">    - get_request() -&gt; request, client_address</span>
<span class="sd">    - handle_timeout()</span>
<span class="sd">    - verify_request(request, client_address)</span>
<span class="sd">    - process_request(request, client_address)</span>
<span class="sd">    - shutdown_request(request)</span>
<span class="sd">    - close_request(request)</span>
<span class="sd">    - handle_error()</span>

<span class="sd">    Methods for derived classes:</span>

<span class="sd">    - finish_request(request, client_address)</span>

<span class="sd">    Class variables that may be overridden by derived classes or</span>
<span class="sd">    instances:</span>

<span class="sd">    - timeout</span>
<span class="sd">    - address_family</span>
<span class="sd">    - socket_type</span>
<span class="sd">    - request_queue_size (only for stream sockets)</span>
<span class="sd">    - allow_reuse_address</span>

<span class="sd">    Instance variables:</span>

<span class="sd">    - server_address</span>
<span class="sd">    - RequestHandlerClass</span>
<span class="sd">    - socket</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">address_family</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span>

    <span class="n">socket_type</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span>

    <span class="n">request_queue_size</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="n">allow_reuse_address</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">server_address</span><span class="p">,</span> <span class="n">RequestHandlerClass</span><span class="p">,</span> <span class="n">bind_and_activate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor.  May be extended, do not override.&quot;&quot;&quot;</span>
        <span class="n">BaseServer</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">server_address</span><span class="p">,</span> <span class="n">RequestHandlerClass</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">address_family</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">socket_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bind_and_activate</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">server_bind</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">server_activate</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">server_close</span><span class="p">()</span>
                <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">server_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called by constructor to bind the socket.</span>

<span class="sd">        May be overridden.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_reuse_address</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">server_address</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server_address</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">getsockname</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">server_activate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called by constructor to activate the server.</span>

<span class="sd">        May be overridden.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">request_queue_size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">server_close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called to clean-up the server.</span>

<span class="sd">        May be overridden.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return socket file number.</span>

<span class="sd">        Interface required by selector.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_request</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the request and client address from the socket.</span>

<span class="sd">        May be overridden.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">shutdown_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called to shutdown and close an individual request.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1">#explicitly shutdown.  socket.close() merely releases</span>
            <span class="c1">#the socket and waits for GC to perform the actual close.</span>
            <span class="n">request</span><span class="o">.</span><span class="n">shutdown</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SHUT_WR</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
            <span class="k">pass</span> <span class="c1">#some platforms may raise ENOTCONN here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">close_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called to clean up an individual request.&quot;&quot;&quot;</span>
        <span class="n">request</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">UDPServer</span><span class="p">(</span><span class="n">TCPServer</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;UDP server class.&quot;&quot;&quot;</span>

    <span class="n">allow_reuse_address</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">socket_type</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_DGRAM</span>

    <span class="n">max_packet_size</span> <span class="o">=</span> <span class="mi">8192</span>

    <span class="k">def</span> <span class="nf">get_request</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">client_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">recvfrom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_packet_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="p">),</span> <span class="n">client_addr</span>

    <span class="k">def</span> <span class="nf">server_activate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># No need to call listen() for UDP.</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">shutdown_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="c1"># No need to shutdown anything.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">close_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="c1"># No need to close anything.</span>
        <span class="k">pass</span>

<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s2">&quot;fork&quot;</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">ForkingMixIn</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Mix-in class to handle each request in a new process.&quot;&quot;&quot;</span>

        <span class="n">timeout</span> <span class="o">=</span> <span class="mi">300</span>
        <span class="n">active_children</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">max_children</span> <span class="o">=</span> <span class="mi">40</span>
        <span class="c1"># If true, server_close() waits until all child processes complete.</span>
        <span class="n">_block_on_close</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">def</span> <span class="nf">collect_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Internal routine to wait for children that have exited.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="c1"># If we&#39;re above the max number of children, wait and reap them until</span>
            <span class="c1"># we go back below threshold. Note that we use waitpid(-1) below to be</span>
            <span class="c1"># able to collect children in size(&lt;defunct children&gt;) syscalls instead</span>
            <span class="c1"># of size(&lt;children&gt;): the downside is that this might reap children</span>
            <span class="c1"># which we didn&#39;t spawn, which is why we only resort to this when we&#39;re</span>
            <span class="c1"># above max_children.</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">active_children</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_children</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">pid</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">waitpid</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ChildProcessError</span><span class="p">:</span>
                    <span class="c1"># we don&#39;t have any children, we&#39;re done</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="c1"># Now reap all defunct children.</span>
            <span class="k">for</span> <span class="n">pid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span><span class="o">.</span><span class="n">copy</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">blocking</span> <span class="k">else</span> <span class="n">os</span><span class="o">.</span><span class="n">WNOHANG</span>
                    <span class="n">pid</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">waitpid</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
                    <span class="c1"># if the child hasn&#39;t exited yet, pid will be 0 and ignored by</span>
                    <span class="c1"># discard() below</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ChildProcessError</span><span class="p">:</span>
                    <span class="c1"># someone else reaped it</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">def</span> <span class="nf">handle_timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Wait for zombies after self.timeout seconds of inactivity.</span>

<span class="sd">            May be extended, do not override.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collect_children</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">service_actions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Collect the zombie child processes regularly in the ForkingMixIn.</span>

<span class="sd">            service_actions is called in the BaseServer&#39;s serve_forver loop.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collect_children</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">process_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Fork a new subprocess to process the request.&quot;&quot;&quot;</span>
            <span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fork</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">pid</span><span class="p">:</span>
                <span class="c1"># Parent process</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">active_children</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">close_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Child process.</span>
                <span class="c1"># This must never return, hence os._exit()!</span>
                <span class="n">status</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">finish_request</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">)</span>
                    <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">handle_error</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">)</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">shutdown_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
                    <span class="k">finally</span><span class="p">:</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">_exit</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">server_close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">server_close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collect_children</span><span class="p">(</span><span class="n">blocking</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_block_on_close</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ThreadingMixIn</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Mix-in class to handle each request in a new thread.&quot;&quot;&quot;</span>

    <span class="c1"># Decides how threads will act upon termination of the</span>
    <span class="c1"># main process</span>
    <span class="n">daemon_threads</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># If true, server_close() waits until all non-daemonic threads terminate.</span>
    <span class="n">_block_on_close</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># For non-daemonic threads, list of threading.Threading objects</span>
    <span class="c1"># used by server_close() to wait for all threads completion.</span>
    <span class="n">_threads</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">process_request_thread</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Same as in BaseServer but as a thread.</span>

<span class="sd">        In addition, exception handling is done here.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finish_request</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle_error</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shutdown_request</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">process_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Start a new thread to process the request.&quot;&quot;&quot;</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_request_thread</span><span class="p">,</span>
                             <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">))</span>
        <span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">daemon_threads</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block_on_close</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_threads</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_threads</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_threads</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">server_close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">server_close</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_block_on_close</span><span class="p">:</span>
            <span class="n">threads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_threads</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_threads</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">threads</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
                    <span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>


<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">os</span><span class="p">,</span> <span class="s2">&quot;fork&quot;</span><span class="p">):</span>
    <span class="k">class</span> <span class="nc">ForkingUDPServer</span><span class="p">(</span><span class="n">ForkingMixIn</span><span class="p">,</span> <span class="n">UDPServer</span><span class="p">):</span> <span class="k">pass</span>
    <span class="k">class</span> <span class="nc">ForkingTCPServer</span><span class="p">(</span><span class="n">ForkingMixIn</span><span class="p">,</span> <span class="n">TCPServer</span><span class="p">):</span> <span class="k">pass</span>

<span class="k">class</span> <span class="nc">ThreadingUDPServer</span><span class="p">(</span><span class="n">ThreadingMixIn</span><span class="p">,</span> <span class="n">UDPServer</span><span class="p">):</span> <span class="k">pass</span>
<span class="k">class</span> <span class="nc">ThreadingTCPServer</span><span class="p">(</span><span class="n">ThreadingMixIn</span><span class="p">,</span> <span class="n">TCPServer</span><span class="p">):</span> <span class="k">pass</span>

<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="s1">&#39;AF_UNIX&#39;</span><span class="p">):</span>

    <span class="k">class</span> <span class="nc">UnixStreamServer</span><span class="p">(</span><span class="n">TCPServer</span><span class="p">):</span>
        <span class="n">address_family</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_UNIX</span>

    <span class="k">class</span> <span class="nc">UnixDatagramServer</span><span class="p">(</span><span class="n">UDPServer</span><span class="p">):</span>
        <span class="n">address_family</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_UNIX</span>

    <span class="k">class</span> <span class="nc">ThreadingUnixStreamServer</span><span class="p">(</span><span class="n">ThreadingMixIn</span><span class="p">,</span> <span class="n">UnixStreamServer</span><span class="p">):</span> <span class="k">pass</span>

    <span class="k">class</span> <span class="nc">ThreadingUnixDatagramServer</span><span class="p">(</span><span class="n">ThreadingMixIn</span><span class="p">,</span> <span class="n">UnixDatagramServer</span><span class="p">):</span> <span class="k">pass</span>

<span class="k">class</span> <span class="nc">BaseRequestHandler</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;Base class for request handler classes.</span>

<span class="sd">    This class is instantiated for each request to be handled.  The</span>
<span class="sd">    constructor sets the instance variables request, client_address</span>
<span class="sd">    and server, and then calls the handle() method.  To implement a</span>
<span class="sd">    specific service, all you need to do is to derive a class which</span>
<span class="sd">    defines a handle() method.</span>

<span class="sd">    The handle() method can find the request as self.request, the</span>
<span class="sd">    client address as self.client_address, and the server (in case it</span>
<span class="sd">    needs access to per-server information) as self.server.  Since a</span>
<span class="sd">    separate instance is created for each request, the handle() method</span>
<span class="sd">    can define other arbitrary instance variables.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">client_address</span><span class="p">,</span> <span class="n">server</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">request</span> <span class="o">=</span> <span class="n">request</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">client_address</span> <span class="o">=</span> <span class="n">client_address</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server</span> <span class="o">=</span> <span class="n">server</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">finish</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>


<span class="c1"># The following two classes make it possible to use the same service</span>
<span class="c1"># class for stream or datagram servers.</span>
<span class="c1"># Each class sets up these instance variables:</span>
<span class="c1"># - rfile: a file object from which receives the request is read</span>
<span class="c1"># - wfile: a file object to which the reply is written</span>
<span class="c1"># When the handle() method returns, wfile is flushed properly</span>


<span class="k">class</span> <span class="nc">StreamRequestHandler</span><span class="p">(</span><span class="n">BaseRequestHandler</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Define self.rfile and self.wfile for stream sockets.&quot;&quot;&quot;</span>

    <span class="c1"># Default buffer sizes for rfile, wfile.</span>
    <span class="c1"># We default rfile to buffered because otherwise it could be</span>
    <span class="c1"># really slow for large data (a getc() call per byte); we make</span>
    <span class="c1"># wfile unbuffered because (a) often after a write() we want to</span>
    <span class="c1"># read and we need to flush the line; (b) big writes to unbuffered</span>
    <span class="c1"># files are typically optimized by stdio even when big reads</span>
    <span class="c1"># aren&#39;t.</span>
    <span class="n">rbufsize</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">wbufsize</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># A timeout to apply to the request socket, if not None.</span>
    <span class="n">timeout</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Disable nagle algorithm for this socket, if True.</span>
    <span class="c1"># Use only when wbufsize != 0, to avoid small packets.</span>
    <span class="n">disable_nagle_algorithm</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">settimeout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">disable_nagle_algorithm</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">IPPROTO_TCP</span><span class="p">,</span>
                                       <span class="n">socket</span><span class="o">.</span><span class="n">TCP_NODELAY</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">makefile</span><span class="p">(</span><span class="s1">&#39;rb&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rbufsize</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wbufsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wfile</span> <span class="o">=</span> <span class="n">_SocketWriter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">makefile</span><span class="p">(</span><span class="s1">&#39;wb&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wbufsize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">wfile</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wfile</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
                <span class="c1"># A final socket error may have occurred here, such as</span>
                <span class="c1"># the local error ECONNABORTED.</span>
                <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">_SocketWriter</span><span class="p">(</span><span class="n">BufferedIOBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simple writable BufferedIOBase implementation for a socket</span>

<span class="sd">    Does not hold data in a buffer, avoiding any need to call flush().&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sock</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sock</span> <span class="o">=</span> <span class="n">sock</span>

    <span class="k">def</span> <span class="nf">writable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">as</span> <span class="n">view</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">view</span><span class="o">.</span><span class="n">nbytes</span>

    <span class="k">def</span> <span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sock</span><span class="o">.</span><span class="n">fileno</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">DatagramRequestHandler</span><span class="p">(</span><span class="n">BaseRequestHandler</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Define self.rfile and self.wfile for datagram sockets.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">io</span> <span class="k">import</span> <span class="n">BytesIO</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">packet</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">socket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rfile</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">packet</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wfile</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">socket</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wfile</span><span class="o">.</span><span class="n">getvalue</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_address</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018-19, pynetdicom contributors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>