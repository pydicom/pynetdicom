

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>threading &mdash; pynetdicom3 0.9.1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../_static/css/pynetdicom3.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/pynetdicom3.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> pynetdicom3
          

          
            
            <img src="../_static/pydicom_flat_black.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.9.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../ae_intro.html">ApplicationEntity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../assoc_intro.html">Introduction to Association</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">Package documentation</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pynetdicom3</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>threading</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for threading</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Thread module emulating a subset of Java&#39;s threading model.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">sys</span> <span class="k">as</span> <span class="nn">_sys</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">thread</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">del</span> <span class="n">_sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">]</span>
    <span class="k">raise</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">deque</span> <span class="k">as</span> <span class="n">_deque</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">count</span> <span class="k">as</span> <span class="n">_count</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="k">import</span> <span class="n">time</span> <span class="k">as</span> <span class="n">_time</span><span class="p">,</span> <span class="n">sleep</span> <span class="k">as</span> <span class="n">_sleep</span>
<span class="kn">from</span> <span class="nn">traceback</span> <span class="k">import</span> <span class="n">format_exc</span> <span class="k">as</span> <span class="n">_format_exc</span>

<span class="c1"># Note regarding PEP 8 compliant aliases</span>
<span class="c1">#  This threading model was originally inspired by Java, and inherited</span>
<span class="c1"># the convention of camelCase function and method names from that</span>
<span class="c1"># language. While those names are not in any imminent danger of being</span>
<span class="c1"># deprecated, starting with Python 2.6, the module now provides a</span>
<span class="c1"># PEP 8 compliant alias for any such method name.</span>
<span class="c1"># Using the new PEP 8 compliant names also facilitates substitution</span>
<span class="c1"># with the multiprocessing module, which doesn&#39;t provide the old</span>
<span class="c1"># Java inspired names.</span>


<span class="c1"># Rename some stuff so &quot;from threading import *&quot; is safe</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;activeCount&#39;</span><span class="p">,</span> <span class="s1">&#39;active_count&#39;</span><span class="p">,</span> <span class="s1">&#39;Condition&#39;</span><span class="p">,</span> <span class="s1">&#39;currentThread&#39;</span><span class="p">,</span>
           <span class="s1">&#39;current_thread&#39;</span><span class="p">,</span> <span class="s1">&#39;enumerate&#39;</span><span class="p">,</span> <span class="s1">&#39;Event&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Lock&#39;</span><span class="p">,</span> <span class="s1">&#39;RLock&#39;</span><span class="p">,</span> <span class="s1">&#39;Semaphore&#39;</span><span class="p">,</span> <span class="s1">&#39;BoundedSemaphore&#39;</span><span class="p">,</span> <span class="s1">&#39;Thread&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Timer&#39;</span><span class="p">,</span> <span class="s1">&#39;setprofile&#39;</span><span class="p">,</span> <span class="s1">&#39;settrace&#39;</span><span class="p">,</span> <span class="s1">&#39;local&#39;</span><span class="p">,</span> <span class="s1">&#39;stack_size&#39;</span><span class="p">]</span>

<span class="n">_start_new_thread</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="n">start_new_thread</span>
<span class="n">_allocate_lock</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="n">allocate_lock</span>
<span class="n">_get_ident</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="n">get_ident</span>
<span class="n">ThreadError</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="n">error</span>
<span class="k">del</span> <span class="n">thread</span>


<span class="c1"># sys.exc_clear is used to work around the fact that except blocks</span>
<span class="c1"># don&#39;t fully clear the exception until 3.0.</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
                        <span class="n">module</span><span class="o">=</span><span class="s1">&#39;threading&#39;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="s1">&#39;sys.exc_clear&#39;</span><span class="p">)</span>

<span class="c1"># Debug support (adapted from ihooks.py).</span>
<span class="c1"># All the major classes here derive from _Verbose.  We force that to</span>
<span class="c1"># be a new-style class so that all the major classes here are new-style.</span>
<span class="c1"># This helps debugging (type(instance) is more revealing for instances</span>
<span class="c1"># of new-style classes).</span>

<span class="n">_VERBOSE</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>

    <span class="k">class</span> <span class="nc">_Verbose</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">verbose</span> <span class="o">=</span> <span class="n">_VERBOSE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="k">def</span> <span class="nf">_note</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">format</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__verbose</span><span class="p">:</span>
                <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span> <span class="o">%</span> <span class="n">args</span>
                <span class="c1"># Issue #4188: calling current_thread() can incur an infinite</span>
                <span class="c1"># recursion if it has to create a DummyThread on the fly.</span>
                <span class="n">ident</span> <span class="o">=</span> <span class="n">_get_ident</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">_active</span><span class="p">[</span><span class="n">ident</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&lt;OS thread </span><span class="si">%d</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">ident</span>
                <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">format</span><span class="p">)</span>
                <span class="n">_sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">format</span><span class="p">)</span>

<span class="k">else</span><span class="p">:</span>
    <span class="c1"># Disable this when using &quot;python -O&quot;</span>
    <span class="k">class</span> <span class="nc">_Verbose</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">def</span> <span class="nf">_note</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="k">pass</span>

<span class="c1"># Support for profile and trace hooks</span>

<span class="n">_profile_hook</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">_trace_hook</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">setprofile</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set a profile function for all threads started from the threading module.</span>

<span class="sd">    The func will be passed to sys.setprofile() for each thread, before its</span>
<span class="sd">    run() method is called.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_profile_hook</span>
    <span class="n">_profile_hook</span> <span class="o">=</span> <span class="n">func</span>

<span class="k">def</span> <span class="nf">settrace</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set a trace function for all threads started from the threading module.</span>

<span class="sd">    The func will be passed to sys.settrace() for each thread, before its run()</span>
<span class="sd">    method is called.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">_trace_hook</span>
    <span class="n">_trace_hook</span> <span class="o">=</span> <span class="n">func</span>

<span class="c1"># Synchronization classes</span>

<span class="n">Lock</span> <span class="o">=</span> <span class="n">_allocate_lock</span>

<span class="k">def</span> <span class="nf">RLock</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Factory function that returns a new reentrant lock.</span>

<span class="sd">    A reentrant lock must be released by the thread that acquired it. Once a</span>
<span class="sd">    thread has acquired a reentrant lock, the same thread may acquire it again</span>
<span class="sd">    without blocking; the thread must release it once for each time it has</span>
<span class="sd">    acquired it.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_RLock</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_RLock</span><span class="p">(</span><span class="n">_Verbose</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A reentrant lock must be released by the thread that acquired it. Once a</span>
<span class="sd">       thread has acquired a reentrant lock, the same thread may acquire it</span>
<span class="sd">       again without blocking; the thread must release it once for each time it</span>
<span class="sd">       has acquired it.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">_Verbose</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__block</span> <span class="o">=</span> <span class="n">_allocate_lock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">owner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">owner</span> <span class="o">=</span> <span class="n">_active</span><span class="p">[</span><span class="n">owner</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2"> owner=</span><span class="si">%r</span><span class="s2"> count=</span><span class="si">%d</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__count</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Acquire a lock, blocking or non-blocking.</span>

<span class="sd">        When invoked without arguments: if this thread already owns the lock,</span>
<span class="sd">        increment the recursion level by one, and return immediately. Otherwise,</span>
<span class="sd">        if another thread owns the lock, block until the lock is unlocked. Once</span>
<span class="sd">        the lock is unlocked (not owned by any thread), then grab ownership, set</span>
<span class="sd">        the recursion level to one, and return. If more than one thread is</span>
<span class="sd">        blocked waiting until the lock is unlocked, only one at a time will be</span>
<span class="sd">        able to grab ownership of the lock. There is no return value in this</span>
<span class="sd">        case.</span>

<span class="sd">        When invoked with the blocking argument set to true, do the same thing</span>
<span class="sd">        as when called without arguments, and return true.</span>

<span class="sd">        When invoked with the blocking argument set to false, do not block. If a</span>
<span class="sd">        call without an argument would block, return false immediately;</span>
<span class="sd">        otherwise, do the same thing as when called without arguments, and</span>
<span class="sd">        return true.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">me</span> <span class="o">=</span> <span class="n">_get_ident</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">==</span> <span class="n">me</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.acquire(</span><span class="si">%s</span><span class="s2">): recursive success&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">blocking</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rc</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">=</span> <span class="n">me</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.acquire(</span><span class="si">%s</span><span class="s2">): initial success&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.acquire(</span><span class="si">%s</span><span class="s2">): failure&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rc</span>

    <span class="fm">__enter__</span> <span class="o">=</span> <span class="n">acquire</span>

    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Release a lock, decrementing the recursion level.</span>

<span class="sd">        If after the decrement it is zero, reset the lock to unlocked (not owned</span>
<span class="sd">        by any thread), and if any other threads are blocked waiting for the</span>
<span class="sd">        lock to become unlocked, allow exactly one of them to proceed. If after</span>
<span class="sd">        the decrement the recursion level is still nonzero, the lock remains</span>
<span class="sd">        locked and owned by the calling thread.</span>

<span class="sd">        Only call this method when the calling thread owns the lock. A</span>
<span class="sd">        RuntimeError is raised if this method is called when the lock is</span>
<span class="sd">        unlocked.</span>

<span class="sd">        There is no return value.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">!=</span> <span class="n">_get_ident</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot release un-acquired lock&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">=</span> <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">count</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.release(): final release&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.release(): non-final release&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="c1"># Internal methods used by condition variables</span>

    <span class="k">def</span> <span class="nf">_acquire_restore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_owner</span><span class="p">):</span>
        <span class="n">count</span><span class="p">,</span> <span class="n">owner</span> <span class="o">=</span> <span class="n">count_owner</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">=</span> <span class="n">count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">=</span> <span class="n">owner</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">._acquire_restore()&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_release_save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">._release_save()&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">owner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">owner</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_owned</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__owner</span> <span class="o">==</span> <span class="n">_get_ident</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">Condition</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Factory function that returns a new condition variable object.</span>

<span class="sd">    A condition variable allows one or more threads to wait until they are</span>
<span class="sd">    notified by another thread.</span>

<span class="sd">    If the lock argument is given and not None, it must be a Lock or RLock</span>
<span class="sd">    object, and it is used as the underlying lock. Otherwise, a new RLock object</span>
<span class="sd">    is created and used as the underlying lock.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_Condition</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_Condition</span><span class="p">(</span><span class="n">_Verbose</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Condition variables allow one or more threads to wait until they are</span>
<span class="sd">       notified by another thread.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lock</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">_Verbose</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lock</span> <span class="o">=</span> <span class="n">RLock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span> <span class="o">=</span> <span class="n">lock</span>
        <span class="c1"># Export the lock&#39;s acquire() and release() methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">acquire</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">release</span>
        <span class="c1"># If the lock defines _release_save() and/or _acquire_restore(),</span>
        <span class="c1"># these override the default implementations (which just call</span>
        <span class="c1"># release() and acquire() on the lock).  Ditto for _is_owned().</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_release_save</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">_release_save</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_acquire_restore</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">_acquire_restore</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_owned</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">_is_owned</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="fm">__enter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="fm">__exit__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;Condition(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%d</span><span class="s2">)&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_release_save</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>           <span class="c1"># No state to save</span>

    <span class="k">def</span> <span class="nf">_acquire_restore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>           <span class="c1"># Ignore saved state</span>

    <span class="k">def</span> <span class="nf">_is_owned</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Return True if lock is owned by current_thread.</span>
        <span class="c1"># This method is called only if __lock doesn&#39;t have _is_owned().</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wait until notified or until a timeout occurs.</span>

<span class="sd">        If the calling thread has not acquired the lock when this method is</span>
<span class="sd">        called, a RuntimeError is raised.</span>

<span class="sd">        This method releases the underlying lock, and then blocks until it is</span>
<span class="sd">        awakened by a notify() or notifyAll() call for the same condition</span>
<span class="sd">        variable in another thread, or until the optional timeout occurs. Once</span>
<span class="sd">        awakened or timed out, it re-acquires the lock and returns.</span>

<span class="sd">        When the timeout argument is present and not None, it should be a</span>
<span class="sd">        floating point number specifying a timeout for the operation in seconds</span>
<span class="sd">        (or fractions thereof).</span>

<span class="sd">        When the underlying lock is an RLock, it is not released using its</span>
<span class="sd">        release() method, since this may not actually unlock the lock when it</span>
<span class="sd">        was acquired multiple times recursively. Instead, an internal interface</span>
<span class="sd">        of the RLock class is used, which really unlocks it even when it has</span>
<span class="sd">        been recursively acquired several times. Another internal interface is</span>
<span class="sd">        then used to restore the recursion level when the lock is reacquired.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_owned</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot wait on un-acquired lock&quot;</span><span class="p">)</span>
        <span class="n">waiter</span> <span class="o">=</span> <span class="n">_allocate_lock</span><span class="p">()</span>
        <span class="n">waiter</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">waiter</span><span class="p">)</span>
        <span class="n">saved_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_release_save</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>    <span class="c1"># restore state no matter what (e.g., KeyboardInterrupt)</span>
            <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">waiter</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.wait(): got it&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Balancing act:  We can&#39;t afford a pure busy loop, so we</span>
                <span class="c1"># have to sleep; but if we sleep the whole timeout time,</span>
                <span class="c1"># we&#39;ll be unresponsive.  The scheme here sleeps very</span>
                <span class="c1"># little at first, longer as time goes on, but never longer</span>
                <span class="c1"># than 20 times per second (or the timeout time remaining).</span>
                <span class="n">endtime</span> <span class="o">=</span> <span class="n">_time</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span>
                <span class="n">delay</span> <span class="o">=</span> <span class="mf">0.0005</span> <span class="c1"># 500 us -&gt; initial delay of 1 ms</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">gotit</span> <span class="o">=</span> <span class="n">waiter</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">gotit</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">remaining</span> <span class="o">=</span> <span class="n">endtime</span> <span class="o">-</span> <span class="n">_time</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">remaining</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="n">delay</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">delay</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="o">.</span><span class="mi">05</span><span class="p">)</span>
                    <span class="n">_sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">gotit</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.wait(</span><span class="si">%s</span><span class="s2">): timed out&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">waiter</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.wait(</span><span class="si">%s</span><span class="s2">): got it&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_acquire_restore</span><span class="p">(</span><span class="n">saved_state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">notify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wake up one or more threads waiting on this condition, if any.</span>

<span class="sd">        If the calling thread has not acquired the lock when this method is</span>
<span class="sd">        called, a RuntimeError is raised.</span>

<span class="sd">        This method wakes up at most n of the threads waiting for the condition</span>
<span class="sd">        variable; it is a no-op if no threads are waiting.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_owned</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot notify on un-acquired lock&quot;</span><span class="p">)</span>
        <span class="n">__waiters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span>
        <span class="n">waiters</span> <span class="o">=</span> <span class="n">__waiters</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">waiters</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.notify(): no waiters&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.notify(): notifying </span><span class="si">%d</span><span class="s2"> waiter</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span>
                   <span class="n">n</span><span class="o">!=</span><span class="mi">1</span> <span class="ow">and</span> <span class="s2">&quot;s&quot;</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">waiter</span> <span class="ow">in</span> <span class="n">waiters</span><span class="p">:</span>
            <span class="n">waiter</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">__waiters</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">waiter</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">notifyAll</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wake up all threads waiting on this condition.</span>

<span class="sd">        If the calling thread has not acquired the lock when this method</span>
<span class="sd">        is called, a RuntimeError is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__waiters</span><span class="p">))</span>

    <span class="n">notify_all</span> <span class="o">=</span> <span class="n">notifyAll</span>


<span class="k">def</span> <span class="nf">Semaphore</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A factory function that returns a new semaphore.</span>

<span class="sd">    Semaphores manage a counter representing the number of release() calls minus</span>
<span class="sd">    the number of acquire() calls, plus an initial value. The acquire() method</span>
<span class="sd">    blocks if necessary until it can return without making the counter</span>
<span class="sd">    negative. If not given, value defaults to 1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_Semaphore</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_Semaphore</span><span class="p">(</span><span class="n">_Verbose</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Semaphores manage a counter representing the number of release() calls</span>
<span class="sd">       minus the number of acquire() calls, plus an initial value. The acquire()</span>
<span class="sd">       method blocks if necessary until it can return without making the counter</span>
<span class="sd">       negative. If not given, value defaults to 1.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># After Tim Peters&#39; semaphore class, but not quite the same (no maximum)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;semaphore initial value must be &gt;= 0&quot;</span><span class="p">)</span>
        <span class="n">_Verbose</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="n">Lock</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">acquire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Acquire a semaphore, decrementing the internal counter by one.</span>

<span class="sd">        When invoked without arguments: if the internal counter is larger than</span>
<span class="sd">        zero on entry, decrement it by one and return immediately. If it is zero</span>
<span class="sd">        on entry, block, waiting until some other thread has called release() to</span>
<span class="sd">        make it larger than zero. This is done with proper interlocking so that</span>
<span class="sd">        if multiple acquire() calls are blocked, release() will wake exactly one</span>
<span class="sd">        of them up. The implementation may pick one at random, so the order in</span>
<span class="sd">        which blocked threads are awakened should not be relied on. There is no</span>
<span class="sd">        return value in this case.</span>

<span class="sd">        When invoked with blocking set to true, do the same thing as when called</span>
<span class="sd">        without arguments, and return true.</span>

<span class="sd">        When invoked with blocking set to false, do not block. If a call without</span>
<span class="sd">        an argument would block, return false immediately; otherwise, do the</span>
<span class="sd">        same thing as when called without arguments, and return true.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">blocking</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.acquire(</span><span class="si">%s</span><span class="s2">): blocked waiting, value=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.acquire: success, value=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span><span class="p">)</span>
                <span class="n">rc</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">rc</span>

    <span class="fm">__enter__</span> <span class="o">=</span> <span class="n">acquire</span>

    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Release a semaphore, incrementing the internal counter by one.</span>

<span class="sd">        When the counter is zero on entry and another thread is waiting for it</span>
<span class="sd">        to become larger than zero again, wake up that thread.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.release: success, value=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">BoundedSemaphore</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A factory function that returns a new bounded semaphore.</span>

<span class="sd">    A bounded semaphore checks to make sure its current value doesn&#39;t exceed its</span>
<span class="sd">    initial value. If it does, ValueError is raised. In most situations</span>
<span class="sd">    semaphores are used to guard resources with limited capacity.</span>

<span class="sd">    If the semaphore is released too many times it&#39;s a sign of a bug. If not</span>
<span class="sd">    given, value defaults to 1.</span>

<span class="sd">    Like regular semaphores, bounded semaphores manage a counter representing</span>
<span class="sd">    the number of release() calls minus the number of acquire() calls, plus an</span>
<span class="sd">    initial value. The acquire() method blocks if necessary until it can return</span>
<span class="sd">    without making the counter negative. If not given, value defaults to 1.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_BoundedSemaphore</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_BoundedSemaphore</span><span class="p">(</span><span class="n">_Semaphore</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A bounded semaphore checks to make sure its current value doesn&#39;t exceed</span>
<span class="sd">       its initial value. If it does, ValueError is raised. In most situations</span>
<span class="sd">       semaphores are used to guard resources with limited capacity.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">_Semaphore</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">release</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Release a semaphore, incrementing the internal counter by one.</span>

<span class="sd">        When the counter is zero on entry and another thread is waiting for it</span>
<span class="sd">        to become larger than zero again, wake up that thread.</span>

<span class="sd">        If the number of releases exceeds the number of acquires,</span>
<span class="sd">        raise a ValueError.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Semaphore__cond</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Semaphore__value</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_value</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Semaphore released too many times&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Semaphore__value</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_Semaphore__cond</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">Event</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A factory function that returns a new event.</span>

<span class="sd">    Events manage a flag that can be set to true with the set() method and reset</span>
<span class="sd">    to false with the clear() method. The wait() method blocks until the flag is</span>
<span class="sd">    true.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_Event</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_Event</span><span class="p">(</span><span class="n">_Verbose</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A factory function that returns a new event object. An event manages a</span>
<span class="sd">       flag that can be set to true with the set() method and reset to false</span>
<span class="sd">       with the clear() method. The wait() method blocks until the flag is true.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># After Tim Peters&#39; event class (without is_posted())</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">_Verbose</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="n">Lock</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__flag</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_reset_internal_locks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># private!  called by Thread._reset_internal_locks by _after_fork()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">Lock</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">isSet</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">&#39;Return true if and only if the internal flag is true.&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__flag</span>

    <span class="n">is_set</span> <span class="o">=</span> <span class="n">isSet</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the internal flag to true.</span>

<span class="sd">        All threads waiting for the flag to become true are awakened. Threads</span>
<span class="sd">        that call wait() once the flag is true will not block at all.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__flag</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reset the internal flag to false.</span>

<span class="sd">        Subsequently, threads calling wait() will block until set() is called to</span>
<span class="sd">        set the internal flag to true again.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__flag</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Block until the internal flag is true.</span>

<span class="sd">        If the internal flag is true on entry, return immediately. Otherwise,</span>
<span class="sd">        block until another thread calls set() to set the flag to true, or until</span>
<span class="sd">        the optional timeout occurs.</span>

<span class="sd">        When the timeout argument is present and not None, it should be a</span>
<span class="sd">        floating point number specifying a timeout for the operation in seconds</span>
<span class="sd">        (or fractions thereof).</span>

<span class="sd">        This method returns the internal flag on exit, so it will always return</span>
<span class="sd">        True except if a timeout is given and the operation times out.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__flag</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__cond</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__flag</span>

<span class="c1"># Helper to generate new thread names</span>
<span class="n">_counter</span> <span class="o">=</span> <span class="n">_count</span><span class="p">()</span><span class="o">.</span><span class="n">next</span>
<span class="n">_counter</span><span class="p">()</span> <span class="c1"># Consume 0 so first non-main thread has id 1.</span>
<span class="k">def</span> <span class="nf">_newname</span><span class="p">(</span><span class="n">template</span><span class="o">=</span><span class="s2">&quot;Thread-</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">template</span> <span class="o">%</span> <span class="n">_counter</span><span class="p">()</span>

<span class="c1"># Active thread administration</span>
<span class="n">_active_limbo_lock</span> <span class="o">=</span> <span class="n">_allocate_lock</span><span class="p">()</span>
<span class="n">_active</span> <span class="o">=</span> <span class="p">{}</span>    <span class="c1"># maps thread id to Thread object</span>
<span class="n">_limbo</span> <span class="o">=</span> <span class="p">{}</span>


<span class="c1"># Main class for threads</span>

<span class="k">class</span> <span class="nc">Thread</span><span class="p">(</span><span class="n">_Verbose</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class that represents a thread of control.</span>

<span class="sd">    This class can be safely subclassed in a limited fashion.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__initialized</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># Need to store a reference to sys.exc_info for printing</span>
    <span class="c1"># out exceptions when a thread tries to use a global var. during interp.</span>
    <span class="c1"># shutdown and thus raises an exception about trying to perform some</span>
    <span class="c1"># operation on/with a NoneType</span>
    <span class="n">__exc_info</span> <span class="o">=</span> <span class="n">_sys</span><span class="o">.</span><span class="n">exc_info</span>
    <span class="c1"># Keep sys.exc_clear too to clear the exception just before</span>
    <span class="c1"># allowing .join() to return.</span>
    <span class="n">__exc_clear</span> <span class="o">=</span> <span class="n">_sys</span><span class="o">.</span><span class="n">exc_clear</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">args</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This constructor should always be called with keyword arguments. Arguments are:</span>

<span class="sd">        *group* should be None; reserved for future extension when a ThreadGroup</span>
<span class="sd">        class is implemented.</span>

<span class="sd">        *target* is the callable object to be invoked by the run()</span>
<span class="sd">        method. Defaults to None, meaning nothing is called.</span>

<span class="sd">        *name* is the thread name. By default, a unique name is constructed of</span>
<span class="sd">        the form &quot;Thread-N&quot; where N is a small decimal number.</span>

<span class="sd">        *args* is the argument tuple for the target invocation. Defaults to ().</span>

<span class="sd">        *kwargs* is a dictionary of keyword arguments for the target</span>
<span class="sd">        invocation. Defaults to {}.</span>

<span class="sd">        If a subclass overrides the constructor, it must make sure to invoke</span>
<span class="sd">        the base class constructor (Thread.__init__()) before doing anything</span>
<span class="sd">        else to the thread.</span>

<span class="sd">&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">group</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;group argument must be None for now&quot;</span>
        <span class="n">_Verbose</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__target</span> <span class="o">=</span> <span class="n">target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span> <span class="ow">or</span> <span class="n">_newname</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__daemonic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_daemon</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ident</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__started</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__block</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="n">Lock</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># sys.stderr is not stored in the class like</span>
        <span class="c1"># sys.exc_info since it can be changed between instances</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__stderr</span> <span class="o">=</span> <span class="n">_sys</span><span class="o">.</span><span class="n">stderr</span>

    <span class="k">def</span> <span class="nf">_reset_internal_locks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># private!  Called by _after_fork() to reset our internal locks as</span>
        <span class="c1"># they may be in an invalid state leading to a deadlock or crash.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_Thread__block&#39;</span><span class="p">):</span>  <span class="c1"># DummyThread deletes self.__block</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">_reset_internal_locks</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_block</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># used by a unittest</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__block</span>

    <span class="k">def</span> <span class="nf">_set_daemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Overridden in _MainThread and _DummyThread</span>
        <span class="k">return</span> <span class="n">current_thread</span><span class="p">()</span><span class="o">.</span><span class="n">daemon</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">,</span> <span class="s2">&quot;Thread.__init__() was not called&quot;</span>
        <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;initial&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;started&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;stopped&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__daemonic</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">+=</span> <span class="s2">&quot; daemon&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ident</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ident</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Start the thread&#39;s activity.</span>

<span class="sd">        It must be called at most once per thread object. It arranges for the</span>
<span class="sd">        object&#39;s run() method to be invoked in a separate thread of control.</span>

<span class="sd">        This method will raise a RuntimeError if called more than once on the</span>
<span class="sd">        same thread object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;thread.__init__() not called&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;threads can only be started once&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.start(): starting thread&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
            <span class="n">_limbo</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_start_new_thread</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__bootstrap</span><span class="p">,</span> <span class="p">())</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">_limbo</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
            <span class="k">raise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method representing the thread&#39;s activity.</span>

<span class="sd">        You may override this method in a subclass. The standard run() method</span>
<span class="sd">        invokes the callable object passed to the object&#39;s constructor as the</span>
<span class="sd">        target argument, if any, with sequential and keyword arguments taken</span>
<span class="sd">        from the args and kwargs arguments, respectively.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__target</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__target</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">__kwargs</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c1"># Avoid a refcycle if the thread is running a function with</span>
            <span class="c1"># an argument that has a member that points to the thread.</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__kwargs</span>

    <span class="k">def</span> <span class="nf">__bootstrap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Wrapper around the real bootstrap code that ignores</span>
        <span class="c1"># exceptions during interpreter cleanup.  Those typically</span>
        <span class="c1"># happen when a daemon thread wakes up at an unfortunate</span>
        <span class="c1"># moment, finds the world around it destroyed, and raises some</span>
        <span class="c1"># random exception *** while trying to report the exception in</span>
        <span class="c1"># __bootstrap_inner() below ***.  Those random exceptions</span>
        <span class="c1"># don&#39;t help anybody, and they confuse users, so we suppress</span>
        <span class="c1"># them.  We suppress them only when it appears that the world</span>
        <span class="c1"># indeed has already been destroyed, so that exceptions in</span>
        <span class="c1"># __bootstrap_inner() during normal business hours are properly</span>
        <span class="c1"># reported.  Also, we only suppress them for daemonic threads;</span>
        <span class="c1"># if a non-daemonic encounters this, something else is wrong.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__bootstrap_inner</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__daemonic</span> <span class="ow">and</span> <span class="n">_sys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">_set_ident</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__ident</span> <span class="o">=</span> <span class="n">_get_ident</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__bootstrap_inner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_ident</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
            <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
                <span class="n">_active</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__ident</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
                <span class="k">del</span> <span class="n">_limbo</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.__bootstrap(): thread started&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">_trace_hook</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.__bootstrap(): registering trace hook&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="n">_sys</span><span class="o">.</span><span class="n">settrace</span><span class="p">(</span><span class="n">_trace_hook</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_profile_hook</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.__bootstrap(): registering profile hook&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="n">_sys</span><span class="o">.</span><span class="n">setprofile</span><span class="p">(</span><span class="n">_profile_hook</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">SystemExit</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.__bootstrap(): raised SystemExit&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.__bootstrap(): unhandled exception&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="c1"># If sys.stderr is no more (most likely from interpreter</span>
                <span class="c1"># shutdown) use self.__stderr.  Otherwise still use sys (as in</span>
                <span class="c1"># _sys) in case sys.stderr was redefined since the creation of</span>
                <span class="c1"># self.</span>
                <span class="k">if</span> <span class="n">_sys</span> <span class="ow">and</span> <span class="n">_sys</span><span class="o">.</span><span class="n">stderr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">print</span><span class="o">&gt;&gt;</span><span class="n">_sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Exception in thread </span><span class="si">%s</span><span class="s2">:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                         <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">_format_exc</span><span class="p">()))</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stderr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Do the best job possible w/o a huge amt. of code to</span>
                    <span class="c1"># approximate a traceback (code ideas from</span>
                    <span class="c1"># Lib/traceback.py)</span>
                    <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">exc_tb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__exc_info</span><span class="p">()</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="nb">print</span><span class="o">&gt;&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">__stderr</span><span class="p">,</span> <span class="p">(</span>
                            <span class="s2">&quot;Exception in thread &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span>
                            <span class="s2">&quot; (most likely raised during interpreter shutdown):&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="o">&gt;&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">__stderr</span><span class="p">,</span> <span class="p">(</span>
                            <span class="s2">&quot;Traceback (most recent call last):&quot;</span><span class="p">)</span>
                        <span class="k">while</span> <span class="n">exc_tb</span><span class="p">:</span>
                            <span class="nb">print</span><span class="o">&gt;&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">__stderr</span><span class="p">,</span> <span class="p">(</span>
                                <span class="s1">&#39;  File &quot;</span><span class="si">%s</span><span class="s1">&quot;, line </span><span class="si">%s</span><span class="s1">, in </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">exc_tb</span><span class="o">.</span><span class="n">tb_frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_filename</span><span class="p">,</span>
                                    <span class="n">exc_tb</span><span class="o">.</span><span class="n">tb_lineno</span><span class="p">,</span>
                                    <span class="n">exc_tb</span><span class="o">.</span><span class="n">tb_frame</span><span class="o">.</span><span class="n">f_code</span><span class="o">.</span><span class="n">co_name</span><span class="p">))</span>
                            <span class="n">exc_tb</span> <span class="o">=</span> <span class="n">exc_tb</span><span class="o">.</span><span class="n">tb_next</span>
                        <span class="nb">print</span><span class="o">&gt;&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">__stderr</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">))</span>
                    <span class="c1"># Make sure that exc_tb gets deleted since it is a memory</span>
                    <span class="c1"># hog; deleting everything else is just for thoroughness</span>
                    <span class="k">finally</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">exc_tb</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.__bootstrap(): normal return&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="c1"># Prevent a race in</span>
                <span class="c1"># test_threading.test_no_refcycle_through_target when</span>
                <span class="c1"># the exception keeps the target alive past when we</span>
                <span class="c1"># assert that it&#39;s dead.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__exc_clear</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__stop</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># We don&#39;t call self.__delete() because it also</span>
                    <span class="c1"># grabs _active_limbo_lock.</span>
                    <span class="k">del</span> <span class="n">_active</span><span class="p">[</span><span class="n">_get_ident</span><span class="p">()]</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># DummyThreads delete self.__block, but they have no waiters to</span>
        <span class="c1"># notify anyway (join() is forbidden on them).</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_Thread__block&#39;</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__delete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Remove current thread from the dict of currently running threads.&quot;</span>

        <span class="c1"># Notes about running with dummy_thread:</span>
        <span class="c1">#</span>
        <span class="c1"># Must take care to not raise an exception if dummy_thread is being</span>
        <span class="c1"># used (and thus this module is being used as an instance of</span>
        <span class="c1"># dummy_threading).  dummy_thread.get_ident() always returns -1 since</span>
        <span class="c1"># there is only one thread if dummy_thread is being used.  Thus</span>
        <span class="c1"># len(_active) is always &lt;= 1 here, and any Thread instance created</span>
        <span class="c1"># overwrites the (if any) thread currently registered in _active.</span>
        <span class="c1">#</span>
        <span class="c1"># An instance of _MainThread is always created by &#39;threading&#39;.  This</span>
        <span class="c1"># gets overwritten the instant an instance of Thread is created; both</span>
        <span class="c1"># threads return -1 from dummy_thread.get_ident() and thus have the</span>
        <span class="c1"># same key in the dict.  So when the _MainThread instance created by</span>
        <span class="c1"># &#39;threading&#39; tries to clean itself up when atexit calls this method</span>
        <span class="c1"># it gets a KeyError if another Thread instance was created.</span>
        <span class="c1">#</span>
        <span class="c1"># This all means that KeyError from trying to delete something from</span>
        <span class="c1"># _active if dummy_threading is being used is a red herring.  But</span>
        <span class="c1"># since it isn&#39;t if dummy_threading is *not* being used then don&#39;t</span>
        <span class="c1"># hide the exception.</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">_active</span><span class="p">[</span><span class="n">_get_ident</span><span class="p">()]</span>
                <span class="c1"># There must not be any python code between the previous line</span>
                <span class="c1"># and after the lock is released.  Otherwise a tracing function</span>
                <span class="c1"># could try to acquire the lock again in the same thread, (in</span>
                <span class="c1"># current_thread()), and would block.</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;dummy_threading&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
                <span class="k">raise</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wait until the thread terminates.</span>

<span class="sd">        This blocks the calling thread until the thread whose join() method is</span>
<span class="sd">        called terminates -- either normally or through an unhandled exception</span>
<span class="sd">        or until the optional timeout occurs.</span>

<span class="sd">        When the timeout argument is present and not None, it should be a</span>
<span class="sd">        floating point number specifying a timeout for the operation in seconds</span>
<span class="sd">        (or fractions thereof). As join() always returns None, you must call</span>
<span class="sd">        isAlive() after join() to decide whether a timeout happened -- if the</span>
<span class="sd">        thread is still alive, the join() call timed out.</span>

<span class="sd">        When the timeout argument is not present or None, the operation will</span>
<span class="sd">        block until the thread terminates.</span>

<span class="sd">        A thread can be join()ed many times.</span>

<span class="sd">        join() raises a RuntimeError if an attempt is made to join the current</span>
<span class="sd">        thread as that would cause a deadlock. It is also an error to join() a</span>
<span class="sd">        thread before it has been started and attempts to do so raises the same</span>
<span class="sd">        exception.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Thread.__init__() not called&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot join thread before it is started&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">current_thread</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot join current thread&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.join(): waiting until thread stops&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.join(): thread stopped&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">deadline</span> <span class="o">=</span> <span class="n">_time</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span><span class="p">:</span>
                    <span class="n">delay</span> <span class="o">=</span> <span class="n">deadline</span> <span class="o">-</span> <span class="n">_time</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">delay</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.join(): timed out&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.join(): thread stopped&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__block</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A string used for identification purposes only.</span>

<span class="sd">        It has no semantics. Multiple threads may be given the same name. The</span>
<span class="sd">        initial name is set by the constructor.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">,</span> <span class="s2">&quot;Thread.__init__() not called&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">,</span> <span class="s2">&quot;Thread.__init__() not called&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ident</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Thread identifier of this thread or None if it has not been started.</span>

<span class="sd">        This is a nonzero integer. See the thread.get_ident() function. Thread</span>
<span class="sd">        identifiers may be recycled when a thread exits and another thread is</span>
<span class="sd">        created. The identifier is available even after the thread has exited.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">,</span> <span class="s2">&quot;Thread.__init__() not called&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ident</span>

    <span class="k">def</span> <span class="nf">isAlive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return whether the thread is alive.</span>

<span class="sd">        This method returns True just before the run() method starts until just</span>
<span class="sd">        after the run() method terminates. The module function enumerate()</span>
<span class="sd">        returns a list of all alive threads.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">,</span> <span class="s2">&quot;Thread.__init__() not called&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">is_set</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__stopped</span>

    <span class="n">is_alive</span> <span class="o">=</span> <span class="n">isAlive</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">daemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A boolean value indicating whether this thread is a daemon thread (True) or not (False).</span>

<span class="sd">        This must be set before start() is called, otherwise RuntimeError is</span>
<span class="sd">        raised. Its initial value is inherited from the creating thread; the</span>
<span class="sd">        main thread is not a daemon thread and therefore all threads created in</span>
<span class="sd">        the main thread default to daemon = False.</span>

<span class="sd">        The entire Python program exits when no alive non-daemon threads are</span>
<span class="sd">        left.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">,</span> <span class="s2">&quot;Thread.__init__() not called&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__daemonic</span>

    <span class="nd">@daemon</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">daemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daemonic</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__initialized</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Thread.__init__() not called&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__started</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot set daemon status of active thread&quot;</span><span class="p">);</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__daemonic</span> <span class="o">=</span> <span class="n">daemonic</span>

    <span class="k">def</span> <span class="nf">isDaemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">daemon</span>

    <span class="k">def</span> <span class="nf">setDaemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">daemonic</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="n">daemonic</span>

    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">setName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

<span class="c1"># The timer class was contributed by Itamar Shtull-Trauring</span>

<span class="k">def</span> <span class="nf">Timer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Factory function to create a Timer object.</span>

<span class="sd">    Timers call a function after a specified number of seconds:</span>

<span class="sd">        t = Timer(30.0, f, args=[], kwargs={})</span>
<span class="sd">        t.start()</span>
<span class="sd">        t.cancel()     # stop the timer&#39;s action if it&#39;s still waiting</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_Timer</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_Timer</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Call a function after a specified number of seconds:</span>

<span class="sd">            t = Timer(30.0, f, args=[], kwargs={})</span>
<span class="sd">            t.start()</span>
<span class="sd">            t.cancel()     # stop the timer&#39;s action if it&#39;s still waiting</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">[],</span> <span class="n">kwargs</span><span class="o">=</span><span class="p">{}):</span>
        <span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interval</span> <span class="o">=</span> <span class="n">interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="n">Event</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">cancel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stop the timer if it hasn&#39;t finished yet&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="o">.</span><span class="n">is_set</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>

<span class="c1"># Special thread class to represent the main thread</span>
<span class="c1"># This is garbage collected through an exit handler</span>

<span class="k">class</span> <span class="nc">_MainThread</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;MainThread&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Thread__started</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_ident</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
            <span class="n">_active</span><span class="p">[</span><span class="n">_get_ident</span><span class="p">()]</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_set_daemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_exitfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Thread__stop</span><span class="p">()</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">_pickSomeNonDaemonThread</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: waiting for other threads&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">_pickSomeNonDaemonThread</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">__debug__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: exiting&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Thread__delete</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_pickSomeNonDaemonThread</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span><span class="o">.</span><span class="n">daemon</span> <span class="ow">and</span> <span class="n">t</span><span class="o">.</span><span class="n">is_alive</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">t</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="c1"># Dummy thread class to represent threads not started here.</span>
<span class="c1"># These aren&#39;t garbage collected when they die, nor can they be waited for.</span>
<span class="c1"># If they invoke anything in threading.py that calls current_thread(), they</span>
<span class="c1"># leave an entry in the _active dict forever after.</span>
<span class="c1"># Their purpose is to return *something* from current_thread().</span>
<span class="c1"># They are marked as daemon threads so we won&#39;t wait for them</span>
<span class="c1"># when we exit (conform previous semantics).</span>

<span class="k">class</span> <span class="nc">_DummyThread</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">_newname</span><span class="p">(</span><span class="s2">&quot;Dummy-</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">))</span>

        <span class="c1"># Thread.__block consumes an OS-level locking primitive, which</span>
        <span class="c1"># can never be used by a _DummyThread.  Since a _DummyThread</span>
        <span class="c1"># instance is immortal, that&#39;s bad, so release this resource.</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Thread__block</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_Thread__started</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_ident</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
            <span class="n">_active</span><span class="p">[</span><span class="n">_get_ident</span><span class="p">()]</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_set_daemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;cannot join a dummy thread&quot;</span>


<span class="c1"># Global API functions</span>

<span class="k">def</span> <span class="nf">currentThread</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return the current Thread object, corresponding to the caller&#39;s thread of control.</span>

<span class="sd">    If the caller&#39;s thread of control was not created through the threading</span>
<span class="sd">    module, a dummy thread object with limited functionality is returned.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_active</span><span class="p">[</span><span class="n">_get_ident</span><span class="p">()]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="c1">##print &quot;current_thread(): no current thread for&quot;, _get_ident()</span>
        <span class="k">return</span> <span class="n">_DummyThread</span><span class="p">()</span>

<span class="n">current_thread</span> <span class="o">=</span> <span class="n">currentThread</span>

<span class="k">def</span> <span class="nf">activeCount</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return the number of Thread objects currently alive.</span>

<span class="sd">    The returned count is equal to the length of the list returned by</span>
<span class="sd">    enumerate().</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">_active</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">_limbo</span><span class="p">)</span>

<span class="n">active_count</span> <span class="o">=</span> <span class="n">activeCount</span>

<span class="k">def</span> <span class="nf">_enumerate</span><span class="p">():</span>
    <span class="c1"># Same as enumerate(), but without the lock. Internal use only.</span>
    <span class="k">return</span> <span class="n">_active</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="o">+</span> <span class="n">_limbo</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">enumerate</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Return a list of all Thread objects currently alive.</span>

<span class="sd">    The list includes daemonic threads, dummy thread objects created by</span>
<span class="sd">    current_thread(), and the main thread. It excludes terminated threads and</span>
<span class="sd">    threads that have not yet been started.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_active</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="o">+</span> <span class="n">_limbo</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

<span class="kn">from</span> <span class="nn">thread</span> <span class="k">import</span> <span class="n">stack_size</span>

<span class="c1"># Create the main thread object,</span>
<span class="c1"># and make it available for the interpreter</span>
<span class="c1"># (Py_Main) as threading._shutdown.</span>

<span class="n">_shutdown</span> <span class="o">=</span> <span class="n">_MainThread</span><span class="p">()</span><span class="o">.</span><span class="n">_exitfunc</span>

<span class="c1"># get thread-local implementation, either from the thread</span>
<span class="c1"># module, or from the python fallback</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">thread</span> <span class="k">import</span> <span class="n">_local</span> <span class="k">as</span> <span class="n">local</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">_threading_local</span> <span class="k">import</span> <span class="n">local</span>


<span class="k">def</span> <span class="nf">_after_fork</span><span class="p">():</span>
    <span class="c1"># This function is called by Python/ceval.c:PyEval_ReInitThreads which</span>
    <span class="c1"># is called from PyOS_AfterFork.  Here we cleanup threading module state</span>
    <span class="c1"># that should not exist after a fork.</span>

    <span class="c1"># Reset _active_limbo_lock, in case we forked while the lock was held</span>
    <span class="c1"># by another (non-forked) thread.  http://bugs.python.org/issue874900</span>
    <span class="k">global</span> <span class="n">_active_limbo_lock</span>
    <span class="n">_active_limbo_lock</span> <span class="o">=</span> <span class="n">_allocate_lock</span><span class="p">()</span>

    <span class="c1"># fork() only copied the current thread; clear references to others.</span>
    <span class="n">new_active</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">current_thread</span><span class="p">()</span>
    <span class="k">with</span> <span class="n">_active_limbo_lock</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">_enumerate</span><span class="p">():</span>
            <span class="c1"># Any lock/condition variable may be currently locked or in an</span>
            <span class="c1"># invalid state, so we reinitialize them.</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">thread</span><span class="p">,</span> <span class="s1">&#39;_reset_internal_locks&#39;</span><span class="p">):</span>
                <span class="n">thread</span><span class="o">.</span><span class="n">_reset_internal_locks</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">thread</span> <span class="ow">is</span> <span class="n">current</span><span class="p">:</span>
                <span class="c1"># There is only one active thread. We reset the ident to</span>
                <span class="c1"># its new value since it can have changed.</span>
                <span class="n">ident</span> <span class="o">=</span> <span class="n">_get_ident</span><span class="p">()</span>
                <span class="n">thread</span><span class="o">.</span><span class="n">_Thread__ident</span> <span class="o">=</span> <span class="n">ident</span>
                <span class="n">new_active</span><span class="p">[</span><span class="n">ident</span><span class="p">]</span> <span class="o">=</span> <span class="n">thread</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># All the others are already stopped.</span>
                <span class="n">thread</span><span class="o">.</span><span class="n">_Thread__stop</span><span class="p">()</span>

        <span class="n">_limbo</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">_active</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">_active</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_active</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">_active</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>


<span class="c1"># Self-test code</span>

<span class="k">def</span> <span class="nf">_test</span><span class="p">():</span>

    <span class="k">class</span> <span class="nc">BoundedQueue</span><span class="p">(</span><span class="n">_Verbose</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">):</span>
            <span class="n">_Verbose</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mon</span> <span class="o">=</span> <span class="n">RLock</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rc</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mon</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wc</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mon</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">limit</span> <span class="o">=</span> <span class="n">limit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">_deque</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mon</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">limit</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;put(</span><span class="si">%s</span><span class="s2">): queue full&quot;</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wc</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;put(</span><span class="si">%s</span><span class="s2">): appended, length now </span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">,</span>
                       <span class="n">item</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rc</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mon</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mon</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;get(): queue empty&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rc</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
            <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_note</span><span class="p">(</span><span class="s2">&quot;get(): got </span><span class="si">%s</span><span class="s2">, </span><span class="si">%d</span><span class="s2"> left&quot;</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wc</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mon</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">item</span>

    <span class="k">class</span> <span class="nc">ProducerThread</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">quota</span><span class="p">):</span>
            <span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Producer&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quota</span> <span class="o">=</span> <span class="n">quota</span>

        <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">random</span> <span class="k">import</span> <span class="n">random</span>
            <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">quota</span><span class="p">:</span>
                <span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">counter</span><span class="p">))</span>
                <span class="n">_sleep</span><span class="p">(</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.00001</span><span class="p">)</span>


    <span class="k">class</span> <span class="nc">ConsumerThread</span><span class="p">(</span><span class="n">Thread</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
            <span class="n">Thread</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Consumer&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">queue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span>

        <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="nb">print</span> <span class="n">item</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">NP</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">QL</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">NI</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="n">Q</span> <span class="o">=</span> <span class="n">BoundedQueue</span><span class="p">(</span><span class="n">QL</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NP</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">ProducerThread</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">NI</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Producer-</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">P</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">ConsumerThread</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">NI</span><span class="o">*</span><span class="n">NP</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">P</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">_sleep</span><span class="p">(</span><span class="mf">0.000001</span><span class="p">)</span>
    <span class="n">C</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">P</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">C</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">_test</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, pynetdicom3 contributors.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.9.1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>